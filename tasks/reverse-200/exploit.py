#!/usr/bin/python3

import numpy as np

from engine import Engine


FLAG_LENGTH = 38

MATRIX_SIZE = 7

ARG_MATRIX = 1
ARG_VALUE = 2

COMMANDS = {
    'matrix_transpose': (ARG_MATRIX,),
    'matrix_sum': (ARG_MATRIX, ARG_MATRIX),
    'matrix_intsum': (ARG_MATRIX, ARG_VALUE),
    'matrix_xor': (ARG_MATRIX, ARG_MATRIX),
    'matrix_intxor': (ARG_MATRIX, ARG_VALUE),
    'matrix_mul': (ARG_MATRIX, ARG_MATRIX),
    'matrix_intmul': (ARG_MATRIX, ARG_VALUE),
    'matrix_mod': (ARG_MATRIX, ARG_MATRIX),
    'matrix_intmod': (ARG_MATRIX, ARG_VALUE),
    'matrix_modmul': (ARG_MATRIX, ARG_MATRIX, ARG_MATRIX),
    'matrix_intmodmul': (ARG_MATRIX, ARG_MATRIX, ARG_VALUE)
}


def get_matrix(name):
    print('Give me a {0}:'.format(name))
    matrix = input().strip()
    if '{' in matrix:
        matrix = eval('[' + matrix[1:-1] + ']')
    elif '], [' in matrix:
        matrix = sum(eval(matrix), [])
    else:
        matrix = eval(matrix)
    return np.matrix(matrix).reshape((MATRIX_SIZE, MATRIX_SIZE))


def get_exploit_data():
    print('Give me an exploit data:')
    data = []
    line = ' '
    while len(line):
        try:
            line = input().strip()
        except Exception:
            break
        data.append(line)
    return data


def reverse(engine, need, solved):
    while len(solved) - 1:
        command = solved.pop(0)
        func = engine.reverse(command)
        args = [eval(solved.pop()) for _ in range(len(COMMANDS[command])-1)]
        args.append(need)
        need = func(*args)
    return need


def decode_flag(flag):
    flag = sum(flag, [])
    return bytes(flag[:FLAG_LENGTH]).decode()


def main():
    Y = get_matrix('Y')
    modulus = get_matrix('modulus')
    engine = Engine(MATRIX_SIZE)
    ones = np.ones((MATRIX_SIZE, MATRIX_SIZE), 'int')
    X = engine.reverse('matrix_modmul')(Y, modulus, ones)
    exploit = get_exploit_data()
    flag = reverse(engine, X, exploit)
    print(decode_flag(flag))


if __name__ == '__main__':
    main()
