#!/usr/bin/python3

import sys

from random import randint
from Crypto.Util.number import long_to_bytes, bytes_to_long


class SocketWrapper(object):
    def __init__(self, address, timeout=3):
        self._sock = SocketWrapper._makesock(address, timeout)

    def sendline(self, line):
        self._sock.send(line + b'\n')

    def recvline(self):
        return self.recvuntil(b'\n')

    def recvuntil(self, until):
        data = b''
        while not data.endswith(until):
            data += self.recv(1)
        return data

    def recv(self, size):
        data = b''
        while True:
            try:
                data += self._sock.recv(size - len(data))
                if len(data) == size:
                    return data
            except Exception:
                pass

    @staticmethod
    def _makesock(address, timeout):
        from socket import socket
        sock = socket()
        sock.settimeout(timeout)
        sock.connect(address)
        return sock


class Oracle(object):
    MODE_ENCRYPT = 1
    MODE_DECRYPT = 2

    def __init__(self, mode, verbose=True):
        self._mode = mode
        self._verbose = verbose
        self._calls = 0
        self._ciphertext = None
    
    def call(self, number):
        self._calls += 1
        if self._verbose:
            print('[*] Oracle calls: {0}'.format(self._calls))

    def ciphertext(self):
        return self._ciphertext


class RemoteOracle(Oracle):
    def __init__(self, address, mode):
        Oracle.__init__(self, mode)
        self._sock = SocketWrapper(address)
        self._sock.recvline()
        self._set_mode()
        self._get_ciphertext()

    def call(self, number):
        Oracle.call(self, number)
        self._sock.recvuntil(b'> ')
        self._sock.sendline(str(number).encode())
        return int(self._sock.recvline())

    def _set_mode(self):
        self._sock.sendline(str(self._mode).encode())

    def _get_ciphertext(self):
        self._ciphertext = int(self._sock.recvline()[4:])


class LocalOracle(Oracle):
    def __init__(self, plaintext, mode):
        Oracle.__init__(self, mode)
        from rsa import RSA
        from secret import p, q, e
        self._rsa = RSA(p, q, e)
        self._ciphertext = self._rsa.encrypt(bytes_to_long(plaintext))
        self._rsa.set_firewall()

    def call(self, number):
        Oracle.call(self, number)
        if self._mode == Oracle.MODE_DECRYPT:
            return self._rsa.decrypt(number)
        if self._mode == Oracle.MODE_ENCRYPT:
            return self._rsa.encrypt(number)


def recover_exponent(oracle, limit, verbose=True):
    candidates = set(range(1, limit))
    attempts = 1
    while len(candidates) != 1:
        if verbose:
            print(candidates)
        for e in list(candidates):
            messages = (randint(10000, 200000) for _ in range(attempts))
            if any(oracle.call(message**e) != (message & 1) for message in messages):
                candidates.remove(e)
        attempts *= 2
    return candidates.pop()


def recover_modulus(oracle, bits, e, verbose=True):
    n = ''
    for i in range(bits * 2 - 1, -1, -1):
        guess = (int(n + '1', 2) << i) ** e
        output = oracle.call(guess)
        if verbose:
            print(n)
        if output == 0:
            n += '1'
        elif output == 1:
            n += '0'
    return int(n, 2)


def recover_plaintext(oracle, bits, c, e, n, verbose=True):
    lower, upper = 0, n
    for i in range(1, bits*2 - 10):
        chosen = (c * pow(2, i*e, n)) % n
        if verbose:
            print(lower, upper)
        output = oracle.call(chosen)
        if output == 0:
            upper = (upper + lower) // 2
        elif output == 1:
            lower = (lower + upper) // 2
    return lower, upper


def main():
    bits = 512
    # oracle = RemoteOracle(('ctf.kelte.cc', 8844), Oracle.MODE_DECRYPT)
    oracle = LocalOracle(b'guesstheflag!\n', Oracle.MODE_DECRYPT)
    ct = oracle.ciphertext()
    print(ct)
    # e = recover_exponent(oracle, bits)
    e = 417
    print(e)
    # n = recover_modulus(oracle, bits, e)
    n = 117620290437165571553273783914430138348121920496938911516372825471822259564585245378655260823142879779617062513536549200356601012335657832253571929822021304199466092830718117868920384554679977067333004062361018224822412273014264731170830166839512486325799534376075334528511237235941247276224131447461555955207
    print(n)
    l, u = recover_plaintext(oracle, bits, ct, e, n)
    print(l, u)
    for m in range(l, u):
        print(long_to_bytes(m))
    

if __name__ == '__main__':
    main()